---
templateKey: blog-post
title: Site Redesign - Moving to JAMstack using Gatsby, Netlify, and Netlify CMS 
featuredimage: /img/blog-banner-jamstack.jpg
date: 2020-03-18T16:04:10.000Z
featuredpost: false
description: >-
  How I built my personal site and what I learned from using a static site generator   
  (Photo by Alexander Sinn on Unsplash)
tags:
  - process
  - react
  - netlify
  - gatsby
  - PWA
  - JAMstack 
---

### Way Back in the Day
My personal / portfolio site has been <a href="https://web.archive.org/web/20010925084339/http://www.designflea.com/01/">through</a> <a href="https://web.archive.org/web/20030219050545/http://matthewrea.com/">many</a> <a href="https://web.archive.org/web/20100317140322/http://matthewrea.com:80/">questionable</a> and <a href="https://web.archive.org/web/20131126142640/http://matthewrea.com/">varied</a> <a href="https://web.archive.org/web/20131126142640/http://matthewrea.com/">iterations</a>. In the early 2000s, I rolled my own site using PHP and MySQL which was quite nifty in my opinion. Although it wouldn't win any awards, it did the job for a number of years. After long periods of dormancy, I abandoned it after switching hosting providers, and I flirted with using Wordpress or Movable Type. For the last few years, it consisted of a single page, static site updated via FTP very infrequently. Fast forward to 2019, when I started working at 1904labs which provides innovation time - essentially 4 hours a week to work on whatever you want. Static site generators had been around for awhile and I had always wanted to take time to learn, but never really had a good use case with my previous role, so I took the opportunity to dip my toe in the water with a <a href="/work/seven-habits-pwa/">small proof-of-concept project</a> that explored using Gatsby and Netlify. I liked the workflow so much, I decided my next project would be a site refresh.   

### Why JAMstack? 
For me, the attraction came from an appreciation of the performance a static site could provide, paired with a simplicity of the developer experience - a big part of that is git integration and continuous deployment options by providers such as Netlify. The Gatsby ecosystem is easy to get started with, has a rich set of plugins available, and a well-documented API. While some content management frameworks seem very opinionated in terms of their design and data model, I felt like the combination of Gatsby and NetlifyCMS provided the extensibility needed to build a more customized experience, without sacrificing control and visibility into what is happening.   

The result is that the end product is much more performant with less moving parts and security vulnerabilities at runtime which also makes scaling much less expensive. Oh, and did I mention continuous integration and deployment are baked into the workflow? This makes your build and deploy process as simple as pushing to master.

### A New Mental Model
Similarly to how React uprooted some traditional models on how people thought about DOM rendering and manipulation, static site generators flipped around the conventional thinking about how content is served. The classical pattern of serving authored content would include dynamic calls at runtime to fetch content from a database, stuff it in a template, and serve it over the wire. Static sites push the fetching and dynamic calls to build time - leaving runtime more performant as the database lookup and templating machinery are replaced with a simple GET request through a CDN. This is a bit of an oversimplification, as JAMstack sites can also leverage APIs and serverless functions that allow more dynamic behaviors such as ecommerce transactions, but it's useful to understand the shift in broad terms before we start digging into the specifics.   

### Content as Code
JAMstack generally treats content as code that is co-located in your git repository. This represents a shift in thinking from how most content management systems work today which typically store content in some sort of persistent database. To author that content, there is usually a content editor which may have varying levels of WYSIWYG capability. Pages and views may be generated by combining the content and template system, and may also be served by a CMS application server. Meanwhile, other types of pages such as search results, product pages, or account management code is hanndled outside of the CMS. Getting these multiple worlds to play nicely can be a struggle - often content updates and code deployments are on different schedules, and integration / orchestration of releases is messy. The push toward "headless" CMS solutions was an attempt to address some of these issues - treating content as a service and decoupling the CMS authoring and content serving/rendering duties. The headless CMS model still requires content to be stored somewhere outside of the main codebase, which works well for many sites, but if we look at storing content in git rather than an in a separate persistence location, some very interesting things start to happen. Having a pull request for content updates seems a little strange, but it allows us to integrate content lifecycle updates into our git branching & release strategies. It enables preview builds and workflows based on how our code releases already work and provides a source of truth for content and code in a central location.   

So, do content authors need to be taught how to use git? Will they be forced to write content in markdowm or some other unfamiliar language? If so, the adoption of content-as-code doesn't seem so promising. Fortunately, there are several light-weight connectors available that can abstract some of the git workflow and bridge the gap between what content editors are familiar with (Rich Text, maybe a little HTML) and the content markup of choice for static site generators (markdown, yaml, json). If you've ever encountered the "edit" functionality in github's UI for editing things like README files, that is one step toward making git commits a little more user friendly. If we extend that further, structured data in markdown or yaml files can be edited through a familiar form-based UI rather than editing and saving raw files. There is still a lot of room for improvement, but now we have the basic ingredients necessary to make this a viable solution.

### Getting Started
Now that we're finished with the preamble, let's get started. I assume if you're still reading, you have some front-end development knowledge, and while you don't need to be an expert, it certainly helps to have a little experience with React and git. This won't be a step-by-step tutorial, (there are plenty of good resources for that) but I'll try to point out some landmarks and places where I struggled in hopes of filling in some gaps in understanding.  There are several tools and frameworks available, but I will be using the following:
- [Gatsby](https://www.gatsbyjs.org/) - a static site generator which does much of the heavy lifting 
- [Netlify CMS](https://www.netlifycms.org/) - a lightweight, client-side content management system that sits on top of your site and interfaces with your git repo for content updates
- [Netlify](https://www.netlify.com/) - a cloud-based platform that integrates with your git repo for continuous deployment to a global CDN 

We could start from scratch, but I would suggest looking at one of the starter templates available on the Gatsby or Netlify websites. I've found that <a href="https://github.com/netlify-templates/gatsby-starter-netlify-cms"><code>gatsby-starter-netlify-cms</code></a> provides a good base for building without too much overhead, and I'll be referring to it's structure for the remainder of the post. This site was forked from there, and you can always see the source code for this site by looking at <a href="https://github.com/nyan-matt/me">my repo</a>. Follow the README, starting with the <a href="https://app.netlify.com/start/deploy?repository=https://github.com/netlify-templates/gatsby-starter-netlify-cms&stack=cms">Deploy to netlify badge</a> - this will copy the repo into your github account, then build and deploy the example site to Netlify's platform. From here, you can <a href="https://www.netlifycms.org/docs/add-to-your-site/#authentication">setup Netlify Identity and Git Gateway</a> to provide access to the CMS administration dashboard for managing content.      

Once here, I would suggest cloning your remote repo locally, to get your dev environment setup. Gatsby CLI, Netlify CLI, and a recent version of Node are required. When you are up and running, you might want to familiarize yourself with the directory structure, change a few files locally, commit, and push to master. If you've properly connected Github and Netlify, once master has been updated, you should be able to see your app being built and deployed from Netlify's dashboard with your commit message. This part is pretty magical - within a few minutes, you'll see your changes update on the live site. If you've setup Identity, you could login to `your-site-name.netlify.com/admin` to take a look at the Netlify CMS dashboard. Now you could create or edit a new blog post or edit page content, publish your changes, and watch as your content edit is committed to git and a new build is kicked off and deployed to your site. There are settings and options within Netlify to explore, but my experience is that it is pretty turn-key out of the box. 

Once you get acquainted with how the workflow is setup, you can take off your devops hat, because for the most part, you are done. 

### Gatsby 
Gatsby is our static site generator, and where we'll be spending the majority of our time. Based in React, Gatsby allows us to develop an application with reusable components, and much like Create React App, it abstracts away the webpack configuration so it's really easy to develop a modern application without much configuration and setup. Unlike Create React App, being a static site generator, Gatsy supports server rendering of pages which is done when you build your site, rather than at runtime when someone requests the page.   

### Gatsby Ecosystem

```yml
collections:
  - name: "blog"
    label: "Blog"
    folder: "src/pages/blog"
    create: true
    slug: "{{slug}}"
    fields:
      - {label: "Template Key", name: "templateKey", widget: "hidden", default: "blog-post"}
      - {label: "Title", name: "title", widget: "string"}
      - {label: "Publish Date", name: "date", widget: "datetime"}
      - {label: "Description", name: "description", widget: "text"}
      - {label: "Featured Post", name: "featuredpost", widget: "boolean"}
      - {label: "Featured Image", name: "featuredimage", widget: image}
      - {label: "Body", name: "body", widget: "markdown"}
      - {label: "Tags", name: "tags", widget: "list"}

```


### Styling

### Collections - Repeatable Data Patterns vs One-Off Pages 

### GraphQL Data Fetching

### Performance
